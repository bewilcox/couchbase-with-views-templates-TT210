/*
 * Created on $today.date ( Time $today.time )
 * Generated by $generator.name ( version $generator.version )
 */

package ${target.javaPackageFromFolder($SRC)};

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Version implements Comparable<Version> {
	
	private static final Logger LOG = LoggerFactory.getLogger(Version.class);
	private int major;
	private int minor;
	private int rev;

	private Version() {
	}
	
	public Version(int major, int minor, int rev) {
		this();
		this.major = major;
		this.minor = minor;
		this.rev = rev;
	}

	@Override
	public int compareTo(Version candidate) {
		if (this.major != candidate.major) {
            return Integer.compare(this.major, candidate.major);
        }
        if (this.minor != candidate.minor) {
            return Integer.compare(this.minor, candidate.minor);
        }
        if (this.rev != candidate.rev) {
            return Integer.compare(this.rev, candidate.rev);
        }
        return 0;
	}
	
	public boolean isEqual(Version candidate) {
		return (this.compareTo(candidate) == 0);
	}
	
	public boolean isLatest(Version candidate) {
		return (this.compareTo(candidate)==1);
	}
	
	
	public static Version parse(String version) {
        Version returnVersion = null;
		String[] parseVersion = version.split("\\.");
		try {
			if (parseVersion.length > 0) {
				switch (parseVersion.length) {
				case 1:
					returnVersion = new Version(Integer.parseInt(parseVersion[0]),
							0, 0);
					break;
				case 2:
					returnVersion = new Version(Integer.parseInt(parseVersion[0]),
							Integer.parseInt(parseVersion[1]), 0);
					break;
				case 3:
					returnVersion = new Version(Integer.parseInt(parseVersion[0]),
							Integer.parseInt(parseVersion[1]),
							Integer.parseInt(parseVersion[2]));
					break;
				default:
					returnVersion = new Version(Integer.parseInt(parseVersion[0]),
							Integer.parseInt(parseVersion[1]),
							Integer.parseInt(parseVersion[2]));
					break;
				}
			} else {
				returnVersion = new Version(0, 0, 0);
			}
		} catch (NumberFormatException ex) {
			LOG.error("Enabled to parse the expression {} to a version value. [x.y.z] is expected (only integer).",version);
		}

        return returnVersion;
    }
	
	@Override
	public String toString() {
		return major+"."+minor+"."+rev;
	}
	
	public int getMajor() {
		return major;
	}

	public void setMajor(int major) {
		this.major = major;
	}

	public int getMinor() {
		return minor;
	}

	public void setMinor(int minor) {
		this.minor = minor;
	}

	public int getRev() {
		return rev;
	}

	public void setRev(int rev) {
		this.rev = rev;
	}
}
